# -*- coding: utf-8 -*-
"""Harshini.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J1D1vd21zd1vkKrvaEaBqhK_tYCdpBim
"""

import pandas as pd
import seaborn as sns
def output(filename):  ######## This function takes filename as argument and returns the contents of the file as dataframe
    df = pd.read_csv(filename)
    return df
df = output(r"API_19_DS2_en_csv_v2_3931355.csv")

df.info() #### Dataframe information

df['Indicator Name'].value_counts()

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import seaborn as sns

df_land = df.loc[df['Indicator Name'] == 'Arable land (% of land area)']

df_land = df_land.drop(columns=['Country Code', 'Indicator Name', 'Indicator Code' ,'1960','2019','2020'])


df_land = df_land.dropna()

df_land = df_land.reset_index(drop=True)
df_land = df_land.set_index('Country Name')


def f(s):
    return s/s.max()

df_new = df_land.apply(f, axis=0)
clustering_kmeans = KMeans(n_clusters=5)
kmeans = clustering_kmeans.fit_predict(df_new)
#Coordinates of cluster centers with shape [n_clusters, n_features]
clustering_kmeans.fit(df_new).cluster_centers_
#Labels of each point
clustering_kmeans.fit(df_new).labels_

z=df_new[clustering_kmeans.labels_==3] #### selecting countries from cluster number 3

### Run PCA on the data and reduce the dimensions in pca_num_components dimensions

pca_num_components = 2

reduced_data = PCA(n_components=pca_num_components).fit_transform(df_new)
results = pd.DataFrame(reduced_data,columns=['pca1','pca2'])

sns.scatterplot(x="pca1", y="pca2", hue=kmeans, data=results,
              palette=['purple','red','orange','lightgreen','dodgerblue'],
              legend='full',)
plt.title('K-means Clustering with 2 dimensions')
plt.savefig('kmeans.jpg')
plt.show()

z.reset_index(drop=True)
z=z.drop(columns=['index'])
print(z)
print(z.info())
z.loc[z['Country Name'] == 'Italy']

import seaborn as sns
from numpy import arange
from pandas import read_csv
from scipy.optimize import curve_fit

z_melted = z.melt(id_vars=["Country Name"], var_name="Year", value_name="Value")
print(z_melted)
germany_df = z_melted[z_melted["Country Name"]=="Germany"]
germany_df['Year'] = pd.to_numeric(germany_df["Year"])


# objective function
def objective(x, a, b, c):
    return a * x + b * x**2 + c

x = germany_df["Year"]
y = germany_df["Value"] 

# curve fit
popt, _ = curve_fit(objective, x, y)
# summarizing the parameter values
a, b,c = popt
# plot input vs output
plt.scatter(x, y)
# sequence of inputs between the smallest and largest known inputs
x_line = arange(min(x), max(x), 1)
# the output for the range
y_line = objective(x_line, a, b,c)
# line plot for the mapping function
plt.plot(x_line, y_line, '--', color='green')
plt.title("Arable land change over the years for Germany")
plt.xlabel("Years")
plt.ylabel("Arable land (% of land area)")
plt.savefig('samoa.jpg')
plt.show()

import numpy as np
from numpy import sin
from numpy import sqrt

spain_df = z_melted[z_melted["Country Name"]=="Spain"]
spain_df['Year'] = pd.to_numeric(spain_df["Year"])
# define the true objective function
def objective(x, a, b):
    return a * x + b


x = spain_df["Year"]
y = spain_df["Value"] 

# curve fit
popt, _ = curve_fit(objective, x, y)
# summarizing the parameter values
a,b = popt
# plot input vs output
plt.scatter(x, y)
# sequence of inputs between the smallest and largest known inputs
x_line = arange(min(x), max(x), 1)
# the output for the range
y_line = objective(x_line, a,b)
# a line plot for the mapping function
plt.plot(x_line, y_line, '--', color='green')
plt.title("Arable land change over the years for Spain")
plt.xlabel("Years")
plt.ylabel("Arable land (% of land area)")
plt.savefig('spain.jpg')
plt.show()

import numpy as np
from numpy import sin
from numpy import sqrt

italy_df = z_melted[z_melted["Country Name"]=="Italy"]
italy_df['Year'] = pd.to_numeric(italy_df["Year"])
# objective function
def objective(x, a, b, c):
    return a * x + b * x**2 + c

x = italy_df["Year"]
y = italy_df["Value"] 

# curve fit
popg, _ = curve_fit(objective, x, y)
# summarize the parameter values
a, b,c = popg
# plot input vs output
plt.scatter(x, y)
# sequence of inputs between the smallest and largest known inputs
x_line = arange(min(x), max(x), 1)
# the output for the range
y_line = objective(x_line, a, b,c)
# a line plot for the mapping function
plt.plot(x_line, y_line, '--', color='green')
plt.title("Arable land change over the years for Italy")
plt.xlabel("Years")
plt.ylabel("Arable land (% of land area)")
plt.savefig('italy.jpg')
plt.show()

